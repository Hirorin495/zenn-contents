---
title: "chrome拡張のメッセージパッシング"
emoji: "📞"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [chrome拡張機能]
published: true
publushed_at: 2024-12-04 10:00
---

レバウェル開発部アドベントカレンダー4日目担当の高橋です！
業務でここ半年ほどManifestV3に対応したchrome拡張機能を開発していました。
拡張機能を開発するのは初めてで苦労したことはめちゃくちゃありますが、個人的にはメッセージパッシングの理解に苦しめられました。
なので今回はchrome拡張機能でのメッセージパッシングについてまとめようと思います。

# メッセージパッシングの送受信先
メッセージパッシングを理解する上で重要なのが、どこからどこにメッセージを送るか把握することです。
chrome拡張はjsの動く場所が用途に応じて以下のように分かれており、メッセージパッシングをしてデータを連携する必要があります。
（他の拡張機能へのメッセージパッシングはしないものとして考えています）

- Page
    - 画面に表示しているHTMLで動作しているjs
    - アイコンを押した時のポップアップ画面もこれに該当します
- ContentScript
    - manifest.jsonで定義したURLにマッチしたwebページ内で動作するjs
- ServiceWorker
    - バックグラウンドで動作するjs
    - webシステムに例えるとサーバサイドに該当する部分
        - なのでjsだけどDOM操作はできない
- OffscreenDocument
    - ManifestV3からの新機能。新しいウィンドウを開いたりすることなくDOM操作を出来たりします。
      - runtimeAPI以外の機能は使用できない、２つ同時にOffscreenDocumentを開けないという制限があります。
    - 詳しくは[ドキュメント](https://developer.chrome.com/docs/extensions/reference/api/offscreen?hl=ja)を参照


送受信先を図にすると以下のようになります。
![chrome-extension.png](/images/635be87f114f3b/1.png)

ContentScriptだけはchrome拡張内ではなく、manifest.jsonで指定したwebページ側で動作するので分けています。
後述しますがメッセージを送信する際にはこれを意識する必要があります。

# メッセージの送信
2パターンの使い分けをする必要があります。
## パターン1.　送信先がPage, ServiceWorker, OffscreenDocument
chrome拡張内で動作するものは、rutimeAPIのsendMessageメソッドを使って送信します（[ドキュメント](https://developer.chrome.com/docs/extensions/reference/api/runtime?hl=ja#method-sendMessage)）。
```js
chrome.runtime.sendMessage({
  title: 'hoge',
  message: "送るメッセージ"
}, function(response) {
  // 送信先からデータが返された場合はここで受け取り
  console.log(response);
});
```
## パターン2.　送信先がContentScript
送信側はtabsAPIのquery, sendMessageメソッドを使います（[ドキュメント](https://developer.chrome.com/docs/extensions/reference/api/tabs?hl=ja#messaging)）。
使用しているAPIは異なりますが、パターン1とほぼ同じ形です。

```js
chrome.tabs.query({active: true, currentWindow: true}, function (tab) {
  chrome.tabs.sendMessage(tab[0].id, {
    title: 'hoge',
    message: "送るメッセージ"
  }, function(response) {
    // 送信先からデータが返された場合はここで受け取り
    console.log(response);
  });
});
```

# メッセージの受信
メッセージを受信するにはonMessageを使ってリッスンします。
こちらは送信先によって処理は分かれません。
```js
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  console.log('メッセージを受信！')
  console.log(requset) // 送られたメッセージは 引数requestの中にある
  console.log(sender) // 送信元の情報はsenderの中にある
  sendResponse('返事を送る場合はsendResponseメソッドを使う')
});
```

# 苦労した点
送信側で扱うAPIが変わるだけの2パターンしかなくて単純そうですが、パターン1では**送信側のコードで送信先を指定出来ません。**
なので、受信側でメッセージを受け取ってどう処理するかを決める必要があります。

検索するとよく出てくるのは送られたデータから判定する方法です。
switch文でヒットした内容に応じて処理する内容を決め、ヒットしなければ何もしません。

```js
// メッセージ送信
chrome.runtime.sendMessage({type: 'hoge'});

// メッセージ受信
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  switch(request.type) {
    case 'hoge':
      hogeFunc();
      sendMessage('hoge');
      break;
    case 'fuga':
      fugaFunc();
      sendMessage('fuga');
      break;
  }
  return true;
});
```

# おわりに
ManifestV3になってからServiceWorkerの使用が必須になり、windowオブジェクトやDOM操作が出来なくなりました。
そのため、必要な情報をメッセージパッシングでのデータ連携がより重要になっていると感じました。
４つの場所（Page, ServiceWorker, ContentScript, OffscreenDocument）でどんなデータを持ち、連携するのかを理解しないとchrome拡張開発の全体像は見えてこないと思います。
この記事が参考になって、メッセージパッシング理解のお役に立てれば何よりです！

